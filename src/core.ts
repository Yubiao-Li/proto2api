import protoJs from "protobufjs";
import { isPrototype } from "./utils";
import {
  Interface,
  Enum,
  PropertySignature,
  ApiFile,
  ApiModule,
} from "./apiInterface";

export function isEnum(obj) {
  return isPrototype(obj, protoJs.Enum);
}

export function isType(obj) {
  return isPrototype(obj, protoJs.Type);
}

export function isNamespace(obj) {
  return isPrototype(obj, protoJs.Namespace);
}

export function isService(obj) {
  return isPrototype(obj, protoJs.Service);
}

/**
 * Because protobuf.js has special treatment for some modules of google, it needs to be converted
 * // protobuf.js/src/common.js
 * @param typeStr
 * @returns
 */
function getGoogleCommon(typeStr: string) {
  return typeStr === "google.protobuf.Empty" ? "{}" : typeStr;
}

export function initialInterface(
  name: string,
  comment?: string,
  isInitModule: boolean = false
): Interface {
  const result: Interface = {
    name,
    comment,
    members: [],
  };
  if (isInitModule) {
    result.module = {
      comment: `This the module of ${name}`,
      name,
      enums: [],
      interfaces: [],
    };
  }
  return result;
}

export function typeFiledToInterface(item: protoJs.Type): Interface {
  const result: Interface = {
    name: item.name,
    comment: item.comment,
    members: [],
  };

  for (let i = 0; i < item.fieldsArray.length; i++) {
    const field = item.fieldsArray[i];
    if (field.name.match(/\./)) {
      // Filter some strange data generated by protobuf.js itself
      continue;
    }

    const member: PropertySignature = {
      name: field.name,
      type: field.type,
      comment: field.comment,

      // @ts-ignorets
      keyType: field.keyType,
      map: field.map,
      repeated: field.repeated,
      optional: field.options ? field.options["proto3_optional"] : false,
      jsonName: field.options ? field.options["json_name"] : undefined,
      defaultValue: field.options ? field.options["default"] : undefined,
    };
    // If the reference is to another type
    if (field.resolvedType) {
      member.type =
        getGoogleCommon(field.type) != "{}" ? field.resolvedType.name : "{}";
      // write reference path
      member.resolvedPath = field.resolvedType.filename;
    }
    result.members.push(member);
  }

  return result;
}

export function enumFiledToEnum(item: protoJs.Enum): Enum {
  const result: Enum = {
    name: item.name,
    comment: item.comment,
    members: Object.keys(item.values).map((k) => ({
      name: k,
      // initializer: item.values[k],
      initializer: k,
      comment: item.comments[k],
    })),
  };
  return result;
}

const httpType = {
  "(google.api.http).get": "get",
  "(google.api.http).post": "post",
  "(google.api.http).put": "put",
  "(google.api.http).patch": "patch",
  "(google.api.http).delete": "delete",
};
const getHttpType = (options) => {
  const keys = Object.keys(options);
  for (let k of keys) {
    if (httpType[k]) {
      return {
        method: httpType[k],
        url: options[k],
      };
    }
  }

  return {
    method: "No method was found",
    url: "No corresponding URL was found",
  };
};

export function serviceFiledToApiFunction(item: protoJs.Service): ApiModule {
  const result: ApiModule = {
    comment: item.comment,
    name: item.name,
    functions: item.methodsArray.map((k) => {
      const methodUrl = getHttpType(k.options);
      return {
        name: k.name,
        comment: k.comment,
        req: getGoogleCommon(k.requestType),
        url: methodUrl.url,
        res: getGoogleCommon(k.responseType),
        method: methodUrl.method as any,
      };
    }),
  };
  return result;
}

export function findNamespaceName(
  root: protoJs.Namespace,
  name: string = ""
): string {
  const parentName = root.parent.name;
  if (parentName) {
    return findNamespaceName(root.parent, name);
  } else {
    return name;
  }
}

export function findOrInsertParentInterfaceByName(
  apiFile: ApiFile,
  name: string,
  comment: string
): Interface {
  let parentInterface = apiFile.interfaces.find((k) => k.name === name);

  if (!parentInterface) {
    parentInterface = initialInterface(name, comment, true);
    apiFile.interfaces.push(parentInterface);
  }
  return parentInterface;
}
