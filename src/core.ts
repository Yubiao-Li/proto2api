import protoJs from "protobufjs";
import { isPrototype } from "./utils";
import {
  Interface,
  Enum,
  Import,
  PropertySignature,
  ApiModule,
  InterfaceModule,
  DependencyType,
} from "./apiInterface";

export function isEnum(obj) {
  return isPrototype(obj, protoJs.Enum);
}

export function isType(obj) {
  return isPrototype(obj, protoJs.Type);
}

export function isNamespace(obj) {
  return isPrototype(obj, protoJs.Namespace);
}

export function isService(obj) {
  return isPrototype(obj, protoJs.Service);
}

/**
 * Because protobuf.js has special treatment for some modules of google, it needs to be converted
 * // protobuf.js/src/common.js
 * @param typeStr
 * @returns
 */
function getGoogleCommon(typeStr: string) {
  return typeStr === "google.protobuf.Empty" ? "{}" : typeStr;
}

export function typeGenInterfaceModule(child: protoJs.Type): InterfaceModule {
  const result: InterfaceModule = {
    name: child.name,
    comment: `This the module of ${child.name}`,
    enums: [],
    interfaces: [],
  };
  Object.keys(child.nested).forEach((key) => {
    const item = child.nested[key];
    if (isType(item)) {
      result.interfaces.push(typeGenInterface(item as any));
    }
    if (isEnum(item)) {
      result.enums.push(enumGenEnum(item as any));
    }
  });
  return result;
}

export function typeGenInterface(item: protoJs.Type): Interface {
  const result: Interface = {
    name: item.name,
    comment: item.comment,
    members: [],
  };

  for (let i = 0; i < item.fieldsArray.length; i++) {
    const field = item.fieldsArray[i];
    if (field.name.match(/\./)) {
      // Filter some strange data generated by protobuf.js itself
      continue;
    }

    const member: PropertySignature = {
      name: field.name,
      type: field.type,
      dependencyType: DependencyType.SYSTEM,
      comment: field.comment,

      // @ts-ignorets
      keyType: field.keyType,
      map: field.map,
      repeated: field.repeated,
      optional: field.options ? field.options["proto3_optional"] : false,
      jsonName: field.options ? field.options["json_name"] : undefined,
      defaultValue: field.options ? field.options["default"] : undefined,
    };
    // If the reference is to another type
    if (field.resolvedType) {
      member.type =
        getGoogleCommon(field.type) != "{}" ? field.resolvedType.name : "{}";
      // write reference path
      member.resolvedPath =
        field.filename === field.resolvedType.filename
          ? ""
          : field.resolvedType.filename;

      if (field.filename === field.resolvedType.filename) {
        if (field.resolvedType.parent.name === item.name) {
          member.dependencyType = DependencyType.INLINE;
        } else {
          member.dependencyType = DependencyType.CURRENT;
        }
      } else {
        member.dependencyType = DependencyType.EXTERNAL;
      }
    }
    result.members.push(member);
  }

  return result;
}

export function interfaceGenImport(
  _interface: Interface,
  arr: Import[]
): Import[] {
  const insert = (k: PropertySignature) => {
    if (k.dependencyType === DependencyType.EXTERNAL) {
      const index = arr.findIndex((a) => k.resolvedPath === a.resolvedPath);
      if (index > -1) {
        !arr[index].importClause.includes(k.type) &&
          arr[index].importClause.push(k.type);
      } else {
        arr.push({
          importClause: [k.type],
          resolvedPath: k.resolvedPath,
        });
      }
    }
  };
  _interface.members.forEach((k) => insert(k));
  _interface.module?.interfaces?.forEach((i) => {
    i.members.forEach((k) => insert(k));
  });
  return arr;
}

export function enumGenEnum(item: protoJs.Enum): Enum {
  const result: Enum = {
    name: item.name,
    comment: item.comment,
    members: Object.keys(item.values).map((k) => ({
      name: k,
      // initializer: item.values[k],
      initializer: k,
      comment: item.comments[k],
    })),
  };
  return result;
}

const httpType = {
  "(google.api.http).get": "get",
  "(google.api.http).post": "post",
  "(google.api.http).put": "put",
  "(google.api.http).patch": "patch",
  "(google.api.http).delete": "delete",
};
const getHttpType = (options) => {
  const keys = Object.keys(options);
  for (let k of keys) {
    if (httpType[k]) {
      return {
        method: httpType[k],
        url: options[k],
      };
    }
  }

  return {
    method: "No method was found",
    url: "No corresponding URL was found",
  };
};

export function serviceGenApiFunction(item: protoJs.Service): ApiModule {
  const result: ApiModule = {
    comment: item.comment,
    name: item.name,
    functions: item.methodsArray.map((k) => {
      const methodUrl = getHttpType(k.options);
      return {
        name: k.name,
        comment: k.comment,
        req: getGoogleCommon(k.requestType),
        url: methodUrl.url,
        res: getGoogleCommon(k.responseType),
        method: methodUrl.method as any,
      };
    }),
  };
  return result;
}
