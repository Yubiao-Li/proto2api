import protoJs from "protobufjs";
import { isPrototype } from "../utils";
import {
  Interface,
  Enum,
  PropertySignature,
  ApiModule,
  InterfaceModule,
  DependencyType,
  Import,
} from "../apiInterface";

export function isEnum(obj) {
  return isPrototype(obj, protoJs.Enum);
}

export function isType(obj) {
  return isPrototype(obj, protoJs.Type);
}

export function isNamespace(obj) {
  return isPrototype(obj, protoJs.Namespace);
}

export function isService(obj) {
  return isPrototype(obj, protoJs.Service);
}

/**
 * Because protobuf.js has special treatment for some modules of google, it needs to be converted
 * // protobuf.js/src/common.js
 * @param typeStr
 * @returns
 */
function getGoogleCommon(typeStr): string {
  if (typeStr === "google.protobuf.Empty") {
    return "{}";
  }
  if (typeStr === "google.protobuf.Any") return `any`;
  return "";
}

export function typeGenInterfaceModule(child: protoJs.Type): InterfaceModule {
  const result: InterfaceModule = {
    name: child.name,
    comment: `This the module of ${child.name}`,
    enums: [],
    interfaces: [],
  };
  Object.keys(child.nested).forEach((key) => {
    const item = child.nested[key];
    if (isType(item)) {
      result.interfaces.push(typeGenInterface(item as any));
    }
    if (isEnum(item)) {
      result.enums.push(enumGenEnum(item as any));
    }
  });
  return result;
}

export function typeGenInterface(item: protoJs.Type): Interface {
  const result: Interface = {
    name: item.name,
    comment: item.comment,
    members: [],
  };

  for (let i = 0; i < item.fieldsArray.length; i++) {
    const field = item.fieldsArray[i];
    if (field.name.match(/\./)) {
      // Filter some strange data generated by protobuf.js itself
      continue;
    }
    // if (field.type.match(/xx/)) {
    //   debugger;
    // }

    const member: PropertySignature = {
      name: field.name,
      type: field.type,
      dependencyType: DependencyType.SYSTEM,
      comment: field.comment,

      // @ts-ignorets
      keyType: field.keyType,
      map: field.map,
      repeated: field.repeated,
      optional: field.options ? field.options["proto3_optional"] : false,
      jsonName: field.options ? field.options["json_name"] : undefined,
      defaultValue: field.options ? field.options["default"] : undefined,
    };
    // If the reference is to another type
    if (field.resolvedType) {
      // member.type = field.resolvedType.name
      // if (field.type.match(/google/)) {
      //   debugger
      // }
      // member.type = field.type.match(/google/) ? field.resolvedType.name : '{}'
      // write reference path
      member.type = getGoogleCommon(field.type) || field.resolvedType.name;
      member.resolvedPath =
        field.filename === field.resolvedType.filename
          ? ""
          : field.resolvedType.filename;

      if (field.filename === field.resolvedType.filename) {
        if (field.resolvedType.parent.name === item.name) {
          member.dependencyType = DependencyType.INLINE;
        } else {
          member.dependencyType = DependencyType.CURRENT;
        }
      } else if (field.resolvedType.filename) {
        member.dependencyType = DependencyType.EXTERNAL;
      }
    }
    result.members.push(member);
  }

  return result;
}

export function interfaceGenImport(
  _interface: Interface,
  arr: Import[],
  apiModules: ApiModule[]
): Import[] {
  const insert = (k: { resolvedPath: string; type: string }) => {
    const index = arr.findIndex((a) => k.resolvedPath === a.resolvedPath);
    if (index > -1) {
      !arr[index].importClause.includes(k.type) &&
        arr[index].importClause.push(k.type);
    } else {
      arr.push({
        importClause: [k.type],
        resolvedPath: k.resolvedPath,
      });
    }
  };
  _interface.members.forEach((k) => {
    if (k.dependencyType === DependencyType.EXTERNAL) {
      insert({ resolvedPath: k.resolvedPath, type: k.type });
    }
  });
  _interface.module?.interfaces?.forEach((i) => {
    i.members.forEach((k) => {
      if (k.dependencyType === DependencyType.EXTERNAL) {
        insert({ resolvedPath: k.resolvedPath, type: k.type });
      }
    });
  });
  apiModules.forEach((k) =>
    k.functions.forEach((f) => {
      if (f.reqResolvedPath) {
        insert({ resolvedPath: f.reqResolvedPath, type: f.req });
      }
      if (f.resResolvedPath) {
        insert({ resolvedPath: f.resResolvedPath, type: f.res });
      }
    })
  );
  return arr;
}

export function enumGenEnum(item: protoJs.Enum): Enum {
  const result: Enum = {
    name: item.name,
    comment: item.comment,
    members: Object.keys(item.values).map((k) => ({
      name: k,
      // initializer: item.values[k],
      initializer: k,
      comment: item.comments[k],
    })),
  };
  return result;
}

const httpType = {
  "(google.api.http).get": "get",
  "(google.api.http).post": "post",
  "(google.api.http).put": "put",
  "(google.api.http).patch": "patch",
  "(google.api.http).delete": "delete",
};
const getHttpType = (options) => {
  const keys = Object.keys(options);
  for (let k of keys) {
    if (httpType[k]) {
      return {
        method: httpType[k],
        url: options[k],
      };
    }
  }

  return {
    method: "No method was found",
    url: "No corresponding URL was found",
  };
};

export function serviceGenApiFunction(item: protoJs.Service): ApiModule {
  const result: ApiModule = {
    comment: item.comment,
    name: item.name,
    functions: item.methodsArray.map((k) => {
      const httpType = getHttpType(k.options);
      // if (httpType.url == "/xxx") {
      //   debugger;
      // }
      const resFn = k.resolvedRequestType.filename;
      const repFn = k.resolvedResponseType.filename;
      let comment = k.comment || "";
      const redirectReg = comment.match(/\@redirect\s*(\S+)/);
      let redirectUrl = "";
      if (redirectReg && redirectReg.length) {
        redirectUrl = redirectReg[1];
        comment = comment.replace(
          /\@redirect\s*(\S+)/,
          "@originUrl: " + httpType.url
        );
      }
      return {
        name: k.name,
        comment,
        req:
          getGoogleCommon(k.requestType) || k.resolvedRequestType
            ? k.resolvedRequestType.name
            : k.requestType,
        reqResolvedPath: resFn === k.filename ? "" : resFn,
        url: httpType.url,
        redirectUrl,
        res:
          getGoogleCommon(k.responseType) || k.resolvedResponseType
            ? k.resolvedResponseType.name
            : k.responseType,
        resResolvedPath: repFn === k.filename ? "" : repFn,
        method: httpType.method as any,
      };
    }),
  };
  return result;
}
